#!/bin/bash
# claude-sandbox - Run Claude Code in an isolated Docker environment
#
# Usage:
#   claude-sandbox local "work on task 123"    # Run locally with Docker Compose
#   claude-sandbox remote "work on task 123"   # Run on k8s cluster
#   claude-sandbox build                       # Build the Docker image
#   claude-sandbox push                        # Push image to registry
#
# Required environment variables:
#   GITHUB_TOKEN              - GitHub token for cloning
#   CLAUDE_CODE_OAUTH_TOKEN   - OAuth token from `claude setup-token` (valid 1 year)
#                               OR use ANTHROPIC_API_KEY instead
#   REPO_URL                  - Repository URL to clone
#
# Optional environment variables:
#   ANTHROPIC_API_KEY   - Alternative to OAuth token (pay-as-you-go API)
#   TELEGRAM_BOT_TOKEN  - Telegram bot token for notifications
#   TELEGRAM_CHAT_ID    - Telegram chat ID for notifications
#   REPO_BRANCH         - Branch to start from (default: main)
#   CLAUDE_IMAGE        - Docker image for k8s (default: claude-sandbox:latest)
#   HAPI_CLI_TOKEN      - Hapi shared secret for mobile/web control
#   HAPI_API_URL        - Hapi hub URL (default: http://host.docker.internal:3006)

set -e

# Find the sandbox installation directory
# Try: script's parent dir (backward compat), then ~/.claude/claude-sandbox (global install)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CANDIDATE_DIR="$(dirname "$SCRIPT_DIR")"

if [ -f "$CANDIDATE_DIR/docker-compose.yml" ]; then
  # Called from bin/ subdirectory (backward compatible)
  SANDBOX_DIR="$CANDIDATE_DIR"
elif [ -f "$HOME/.claude/claude-sandbox/docker-compose.yml" ]; then
  # Global installation
  SANDBOX_DIR="$HOME/.claude/claude-sandbox"
else
  echo -e "\033[0;31m[claude-sandbox]\033[0m Cannot find claude-sandbox installation" >&2
  echo -e "\033[0;31m[claude-sandbox]\033[0m Expected docker-compose.yml in:" >&2
  echo -e "\033[0;31m[claude-sandbox]\033[0m   - $CANDIDATE_DIR" >&2
  echo -e "\033[0;31m[claude-sandbox]\033[0m   - $HOME/.claude/claude-sandbox" >&2
  exit 1
fi

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

log() { echo -e "${GREEN}[claude-sandbox]${NC} $1"; }
warn() { echo -e "${YELLOW}[claude-sandbox]${NC} $1"; }
error() { echo -e "${RED}[claude-sandbox]${NC} $1" >&2; }
success() { echo -e "${GREEN}[claude-sandbox]${NC} ✓ $1"; }

# Auto-detect REPO_URL from current directory if not set
auto_detect_repo() {
  if [ -n "$REPO_URL" ]; then
    # Explicitly set, don't override
    return 0
  fi

  # Try to get git remote from current directory
  local detected_url=$(git -C "$PWD" remote get-url origin 2>/dev/null)
  if [ -z "$detected_url" ]; then
    error "REPO_URL not set and cannot auto-detect from current directory"
    error "Either:"
    error "  1. Run from a git repository with origin remote, or"
    error "  2. Set REPO_URL environment variable"
    return 1
  fi

  # Convert SSH URLs to HTTPS for token authentication
  # git@github.com:user/repo.git -> https://github.com/user/repo.git
  if [[ "$detected_url" =~ ^git@github\.com:(.+)$ ]]; then
    detected_url="https://github.com/${BASH_REMATCH[1]}"
    log "Converted SSH URL to HTTPS for token authentication"
  fi

  export REPO_URL="$detected_url"
  log "Auto-detected REPO_URL: $REPO_URL"
}

# Auto-detect REPO_BRANCH from current directory if not set
auto_detect_branch() {
  if [ -n "$REPO_BRANCH" ]; then
    # Explicitly set, don't override
    return 0
  fi

  # Try to get current branch from current directory
  local detected_branch=$(git -C "$PWD" branch --show-current 2>/dev/null)
  if [ -n "$detected_branch" ]; then
    export REPO_BRANCH="$detected_branch"
    log "Auto-detected REPO_BRANCH: $REPO_BRANCH"
  else
    # Default to main (already handled by entrypoint.sh default)
    log "Using default branch: main"
  fi
}

# Auto-detect Ruby version from .ruby-version file
auto_detect_ruby_version() {
  # Allow manual override via IMAGE_TAG
  if [ -n "$IMAGE_TAG" ]; then
    return 0
  fi

  local ruby_version=""
  local versions_file="$SANDBOX_DIR/ruby-versions.yaml"

  # Try to read .ruby-version from repository
  if [ -d "$PWD/.git" ]; then
    # Local git repository - check if REPO_URL points here
    # Normalize both URLs to compare (SSH vs HTTPS may differ)
    local current_remote=$(git -C "$PWD" remote get-url origin 2>/dev/null || echo "")
    local normalized_remote=$(echo "$current_remote" | sed -E 's|git@github\.com:|https://github.com/|; s|\.git$||')
    local normalized_repo=$(echo "$REPO_URL" | sed -E 's|git@github\.com:|https://github.com/|; s|\.git$||')
    if [ "$normalized_remote" = "$normalized_repo" ] || [ -z "$REPO_URL" ]; then
      # We're in the target repository
      if [ -f "$PWD/.ruby-version" ]; then
        ruby_version=$(cat "$PWD/.ruby-version" | tr -d '[:space:]')
        log "Found .ruby-version in current directory"
      fi
    fi
  fi

  # If not found locally, try git archive for remote repos
  if [ -z "$ruby_version" ] && [ -n "$REPO_URL" ]; then
    # Try git archive (works for both local paths and remote URLs)
    ruby_version=$(git archive --remote="$REPO_URL" HEAD .ruby-version 2>/dev/null | tar -xO 2>/dev/null | tr -d '[:space:]' || echo "")
    if [ -n "$ruby_version" ]; then
      log "Found .ruby-version in repository via git archive"
    fi
  fi

  # If no .ruby-version found, use default
  if [ -z "$ruby_version" ]; then
    local default_version=$(grep -E '^\s*default:\s*"[0-9]+\.[0-9]+"' "$versions_file" | grep -oE '[0-9]+\.[0-9]+')
    export IMAGE_TAG="ruby-${default_version}"
    log "No .ruby-version found, using default: ${IMAGE_TAG}"
    return 0
  fi

  # Extract major.minor from version (e.g., "3.3.1" -> "3.3")
  local major_minor=$(echo "$ruby_version" | grep -oE '^[0-9]+\.[0-9]+')
  if [ -z "$major_minor" ]; then
    error "Invalid .ruby-version format: $ruby_version"
    error "Expected format: X.Y or X.Y.Z (e.g., 3.3 or 3.3.1)"
    return 1
  fi

  # Validate against supported versions
  if ! grep -qE "^\s*\"${major_minor}\":" "$versions_file"; then
    error "Ruby ${major_minor} is not supported"
    error "Supported versions:"
    grep -E '^\s*"[0-9]+\.[0-9]+":\s*"[0-9]' "$versions_file" | sed 's/[":,]//g' | awk '{print "  - Ruby " $1 " (" $2 ")"}'
    error ""
    error "To add support for Ruby ${major_minor}, edit $versions_file and rebuild images with:"
    error "  bin/claude-sandbox build"
    return 1
  fi

  export IMAGE_TAG="ruby-${major_minor}"
  log "Detected Ruby version: ${major_minor} (using image: claude-sandbox:${IMAGE_TAG})"
}

# Extract repository owner from git remote origin
# Handles both SSH (git@github.com:owner/repo.git) and HTTPS (https://github.com/owner/repo.git)
# Returns empty string for non-GitHub remotes (GitLab, Bitbucket, etc.)
get_repo_owner() {
  local git_dir="${1:-.}"
  local remote_url=$(git -C "$git_dir" remote get-url origin 2>/dev/null)
  if [ -z "$remote_url" ]; then
    echo ""
    return 1
  fi

  # Extract owner from both formats
  # SSH: git@github.com:owner/repo.git -> owner
  # HTTPS: https://github.com/owner/repo.git -> owner
  local owner=$(echo "$remote_url" | sed -E 's|^git@github\.com:([^/]+)/.*|\1|; s|^https://github\.com/([^/]+)/.*|\1|')

  # Validate: owner should be alphanumeric with dashes/underscores only
  # If URL didn't match GitHub patterns, sed passes it through unchanged
  # which would contain invalid chars like : / @
  if [[ "$owner" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    echo "$owner"
  else
    # Non-GitHub remote or invalid format, return empty for fallback
    echo ""
    return 1
  fi
}

usage() {
  cat <<EOF
Usage: claude-sandbox <command> [options]

Commands:
  local [options] <task>  Run Claude locally with Docker Compose
  remote <task>           Run Claude on k8s cluster
  build [--force]         Build the Docker image (--force to rebuild without cache)
  push                    Push image to registry
  logs                    Follow logs of running k8s job
  clean                   Clean up completed k8s jobs

Local options:
  -i, --interactive       Run interactively (no task required, opens Claude shell)

Examples:
  claude-sandbox local "fix the login bug"
  claude-sandbox local -i
  claude-sandbox remote "implement feature X"
  claude-sandbox build

Environment variables:
  GITHUB_TOKEN, REPO_URL (required)
  CLAUDE_CODE_OAUTH_TOKEN or ANTHROPIC_API_KEY (one required)
  TELEGRAM_BOT_TOKEN, TELEGRAM_CHAT_ID (optional, for notifications)
  REPO_BRANCH (optional, default: main)
  CLAUDE_IMAGE (optional, for remote)
  HAPI_CLI_TOKEN (optional, enables Hapi mobile/web control)
  HAPI_API_URL (optional, default: http://host.docker.internal:3006)

To get OAuth token (uses your Claude subscription):
  claude setup-token
EOF
}

check_env() {
  local missing=0

  # Auto-detect repository context
  auto_detect_repo || missing=1
  auto_detect_branch

  # Required vars (REPO_URL may have been auto-detected)
  for var in GITHUB_TOKEN REPO_URL; do
    if [ -z "${!var}" ]; then
      error "Missing required environment variable: $var"
      missing=1
    fi
  done

  # Need either OAuth token or API key
  if [ -z "$CLAUDE_CODE_OAUTH_TOKEN" ] && [ -z "$ANTHROPIC_API_KEY" ]; then
    error "Either CLAUDE_CODE_OAUTH_TOKEN or ANTHROPIC_API_KEY is required"
    error "Get OAuth token with: claude setup-token"
    missing=1
  fi

  if [ $missing -eq 1 ]; then
    exit 1
  fi

  # Warn about optional vars
  if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
    warn "Telegram not configured - notifications disabled"
  fi
}

cmd_local() {
  local interactive=false

  # Parse options before the task
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -i|--interactive)
        interactive=true
        shift
        ;;
      -*)
        error "Unknown option: $1"
        usage
        exit 1
        ;;
      *)
        break
        ;;
    esac
  done

  local task="$*"
  if [ -z "$task" ] && [ "$interactive" = false ]; then
    error "Task is required (or use -i for interactive mode)"
    usage
    exit 1
  fi

  check_env

  # Auto-detect Ruby version if not manually set
  auto_detect_ruby_version || exit 1

  # Default to latest if no IMAGE_TAG was set
  IMAGE_TAG="${IMAGE_TAG:-latest}"

  # Detect required services before starting compose
  COMPOSE_PROFILES="claude"  # Always start claude service
  if [ -x "$SANDBOX_DIR/bin/detect-services.sh" ]; then
    DETECTED_PROFILES=$("$SANDBOX_DIR/bin/detect-services.sh" "$REPO_URL" 2>/dev/null || echo "")
    if [ -n "$DETECTED_PROFILES" ]; then
      COMPOSE_PROFILES="$DETECTED_PROFILES"
      log "Detected service requirements: $COMPOSE_PROFILES"
    else
      # Detection failed, use safe defaults (all services)
      COMPOSE_PROFILES="claude with-postgres with-redis"
      warn "Service detection failed, starting all services"
    fi
  else
    # Script missing, use safe defaults
    COMPOSE_PROFILES="claude with-postgres with-redis"
    warn "Detection script not found, starting all services"
  fi

  log "Starting local sandbox..."
  if [ "$interactive" = true ]; then
    log "Mode: interactive"
  else
    log "Task: $task"
  fi
  log "Image: claude-sandbox:${IMAGE_TAG}"

  cd "$SANDBOX_DIR"

  # Check if image exists
  if ! docker images --format '{{.Repository}}:{{.Tag}}' | grep -q "^claude-sandbox:${IMAGE_TAG}$"; then
    error "Image claude-sandbox:${IMAGE_TAG} not found."
    error "Run 'bin/claude-sandbox build' first."
    exit 1
  fi

  # Build profile flags
  PROFILE_FLAGS=""
  for profile in $COMPOSE_PROFILES; do
    PROFILE_FLAGS="$PROFILE_FLAGS --profile $profile"
  done

  # Start dependency services (postgres, redis) before running claude
  # docker compose run only starts depends_on services, which are empty
  local DEP_SERVICES=""
  if echo "$COMPOSE_PROFILES" | grep -q "with-postgres"; then
    DEP_SERVICES="$DEP_SERVICES postgres"
  fi
  if echo "$COMPOSE_PROFILES" | grep -q "with-redis"; then
    DEP_SERVICES="$DEP_SERVICES redis"
  fi
  if [ -n "$DEP_SERVICES" ]; then
    log "Starting dependency services:$DEP_SERVICES"
    IMAGE_TAG="$IMAGE_TAG" docker compose $PROFILE_FLAGS up -d $DEP_SERVICES
  fi

  # Detect interactive mode — use -it if TTY available, -T otherwise
  local INTERACTIVE_FLAGS="-it"
  if [ ! -t 0 ] || [ ! -t 1 ]; then
    INTERACTIVE_FLAGS="-T"
  fi

  # Build env flags for docker compose run
  local ENV_FLAGS=(
    -e SANDBOX_MODE="local"
    -e GITHUB_TOKEN="$GITHUB_TOKEN"
    -e CLAUDE_CODE_OAUTH_TOKEN="${CLAUDE_CODE_OAUTH_TOKEN:-}"
    -e ANTHROPIC_API_KEY="${ANTHROPIC_API_KEY:-}"
    -e REPO_URL="$REPO_URL"
    -e REPO_BRANCH="${REPO_BRANCH:-main}"
    -e TELEGRAM_BOT_TOKEN="${TELEGRAM_BOT_TOKEN:-}"
    -e TELEGRAM_CHAT_ID="${TELEGRAM_CHAT_ID:-}"
    -e HAPI_CLI_TOKEN="${HAPI_CLI_TOKEN:-}"
    -e HAPI_API_URL="${HAPI_API_URL:-}"
  )

  if [ "$interactive" = true ]; then
    ENV_FLAGS+=(-e INTERACTIVE="true")
    # Task is optional in interactive mode but can still be passed as initial context
    if [ -n "$task" ]; then
      ENV_FLAGS+=(-e TASK="$task")
    fi
  else
    ENV_FLAGS+=(-e TASK="$task")
  fi

  # Run with task, passing IMAGE_TAG to docker-compose
  IMAGE_TAG="$IMAGE_TAG" docker compose $PROFILE_FLAGS run $INTERACTIVE_FLAGS --rm \
    "${ENV_FLAGS[@]}" \
    claude
}

# Generate K8s job YAML with conditional sidecars
# Args: needs_postgres (true/false), needs_redis (true/false)
generate_k8s_job_yaml() {
  local needs_postgres="$1"
  local needs_redis="$2"

  # Build env vars section for claude container
  local claude_env_vars='        - name: TASK
          value: "${TASK}"
        - name: REPO_URL
          value: "${REPO_URL}"
        - name: REPO_BRANCH
          value: "${REPO_BRANCH}"'

  # Add DATABASE_URL only if postgres is needed
  if [ "$needs_postgres" = "true" ]; then
    claude_env_vars="${claude_env_vars}
        - name: DATABASE_URL
          value: \"postgis://claude:claude@localhost:5432/\${DATABASE_NAME}\""
  fi

  # Add REDIS_URL only if redis is needed
  if [ "$needs_redis" = "true" ]; then
    claude_env_vars="${claude_env_vars}
        - name: REDIS_URL
          value: \"redis://localhost:6379\""
  fi

  # Always include these env vars
  claude_env_vars="${claude_env_vars}
        - name: RAILS_ENV
          value: \"development\"
        - name: CHROME_BIN
          value: \"/usr/bin/chromium-browser\""

  # Build sidecars section
  local sidecars=""

  if [ "$needs_postgres" = "true" ]; then
    sidecars="${sidecars}
      # Sidecar: Postgres
      - name: postgres-sidecar
        image: postgis/postgis:16-3.4-alpine
        env:
        - name: POSTGRES_USER
          value: claude
        - name: POSTGRES_PASSWORD
          value: claude
        - name: POSTGRES_DB
          value: \${DATABASE_NAME}
        volumeMounts:
        - name: workspace
          mountPath: /var/lib/postgresql/data
          subPath: postgres
        resources:
          requests:
            memory: \"256Mi\"
            cpu: \"100m\"
          limits:
            memory: \"512Mi\"
            cpu: \"500m\""
  fi

  if [ "$needs_redis" = "true" ]; then
    sidecars="${sidecars}
      # Sidecar: Redis
      - name: redis-sidecar
        image: redis:7-alpine
        resources:
          requests:
            memory: \"64Mi\"
            cpu: \"50m\"
          limits:
            memory: \"128Mi\"
            cpu: \"200m\""
  fi

  # Generate complete YAML
  cat <<EOF
# Claude Sandbox - Kubernetes Job (dynamically generated)
# Generated with sidecars: postgres=$needs_postgres redis=$needs_redis
apiVersion: batch/v1
kind: Job
metadata:
  name: \${JOB_NAME}
  labels:
    app: claude-sandbox
    managed-by: claude-sandbox-cli
spec:
  # Auto-cleanup after 1 hour
  ttlSecondsAfterFinished: 3600
  # Don't retry on failure
  backoffLimit: 0
  template:
    metadata:
      labels:
        app: claude-sandbox
    spec:
      restartPolicy: Never

      # Shared memory for Chrome
      volumes:
      - name: dshm
        emptyDir:
          medium: Memory
          sizeLimit: 2Gi
      - name: workspace
        emptyDir: {}
      - name: age-key
        secret:
          secretName: age-key
          optional: true

      containers:
      - name: claude
        image: \${CLAUDE_IMAGE}
        imagePullPolicy: Always
        tty: true
        stdin: true
        env:
${claude_env_vars}
        envFrom:
        - secretRef:
            name: claude-sandbox-secrets
        volumeMounts:
        - name: dshm
          mountPath: /dev/shm
        - name: workspace
          mountPath: /workspace
          subPath: code
        - name: age-key
          mountPath: /secrets
          readOnly: true
        resources:
          requests:
            memory: "2Gi"
            cpu: "1"
          limits:
            memory: "4Gi"
            cpu: "2"
${sidecars}
EOF
}

cmd_remote() {
  local task="$*"
  if [ -z "$task" ]; then
    error "Task is required"
    usage
    exit 1
  fi

  check_env

  # Auto-detect Ruby version if not manually set
  auto_detect_ruby_version || exit 1

  # Detect required services before job creation
  local needs_postgres="false"
  local needs_redis="false"

  if [ -x "$SANDBOX_DIR/bin/detect-services.sh" ]; then
    DETECTED_PROFILES=$("$SANDBOX_DIR/bin/detect-services.sh" "$REPO_URL" 2>/dev/null || echo "")
    if [ -n "$DETECTED_PROFILES" ]; then
      # Parse profiles to set flags
      if echo "$DETECTED_PROFILES" | grep -q "with-postgres"; then
        needs_postgres="true"
      fi
      if echo "$DETECTED_PROFILES" | grep -q "with-redis"; then
        needs_redis="true"
      fi
      log "Detected service requirements: postgres=$needs_postgres redis=$needs_redis"
    else
      # Detection failed, use safe defaults (all services)
      needs_postgres="true"
      needs_redis="true"
      warn "Service detection failed, including all sidecars"
    fi
  else
    # Script missing, use safe defaults
    needs_postgres="true"
    needs_redis="true"
    warn "Detection script not found, including all sidecars"
  fi

  # Check kubectl is available
  if ! command -v kubectl &> /dev/null; then
    error "kubectl not found - required for remote execution"
    exit 1
  fi

  # Check cluster connection
  if ! kubectl cluster-info &> /dev/null; then
    error "Cannot connect to k8s cluster"
    exit 1
  fi

  # Generate unique job name with random suffix to prevent collisions
  # Use LC_ALL=C to avoid locale issues with tr on macOS
  local random_suffix=$(LC_ALL=C tr -dc 'a-z0-9' < /dev/urandom | head -c 4)
  local job_name="claude-sandbox-$(date +%Y%m%d-%H%M%S)-${random_suffix}"

  # Auto-detect CLAUDE_IMAGE from git remote origin owner if not set
  if [ -z "$CLAUDE_IMAGE" ]; then
    local owner=$(get_repo_owner "$SANDBOX_DIR")
    if [ -n "$owner" ]; then
      export CLAUDE_IMAGE="${owner}/claude-sandbox:latest"
      log "Auto-detected CLAUDE_IMAGE: $CLAUDE_IMAGE"
    else
      # Fallback to original hardcoded value if can't detect
      export CLAUDE_IMAGE="landovsky/claude-sandbox:latest"
      warn "Could not detect repository owner, using default: $CLAUDE_IMAGE"
    fi
  fi

  # Append Ruby version tag to image if detected
  local base_image="${CLAUDE_IMAGE}"
  # Remove :latest suffix if present
  base_image="${base_image%:latest}"
  # Add detected tag or default to latest
  local full_image="${base_image}:${IMAGE_TAG:-latest}"

  log "Creating k8s job: $job_name"
  log "Task: $task"
  log "Repository: $REPO_URL"
  log "Branch: ${REPO_BRANCH:-main}"
  log "Image: $full_image"

  # Export for envsubst
  export SANDBOX_MODE="remote"
  export TASK="$task"
  export JOB_NAME="$job_name"
  export CLAUDE_IMAGE="$full_image"
  export REPO_URL="$REPO_URL"
  export REPO_BRANCH="${REPO_BRANCH:-main}"
  export DATABASE_NAME="${DATABASE_NAME:-sandbox_development}"

  # Generate and apply job
  generate_k8s_job_yaml "$needs_postgres" "$needs_redis" | envsubst | kubectl apply -f -

  log "Job created successfully"
  log "Watch logs with: kubectl logs -f job/$job_name"
  log "Or run: claude-sandbox logs"
}

cmd_build() {
  # Parse options
  local force_rebuild=false
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --force)
        force_rebuild=true
        shift
        ;;
      *)
        error "Unknown option: $1"
        usage
        exit 1
        ;;
    esac
  done

  log "Building Docker images for all Ruby versions..."
  if [ "$force_rebuild" = true ]; then
    log "Force rebuild enabled - ignoring cache"
  fi
  cd "$SANDBOX_DIR"

  # Copy Claude config (agents, settings) to build context
  local claude_config="$SANDBOX_DIR/claude-config"
  rm -rf "$claude_config"
  mkdir -p "$claude_config"

  # Copy agents if they exist
  if [ -d "$HOME/.claude/agents" ]; then
    log "Copying agents from ~/.claude/agents/"
    cp -r "$HOME/.claude/agents" "$claude_config/"
  else
    warn "No agents found at ~/.claude/agents/"
    mkdir -p "$claude_config/agents"
  fi

  # Copy artifacts if they exist
  if [ -d "$HOME/.claude/artifacts" ]; then
    log "Copying artifacts from ~/.claude/artifacts/"
    cp -r "$HOME/.claude/artifacts" "$claude_config/"
  fi

  # Copy custom commands if they exist
  if [ -d "$HOME/.claude/commands" ]; then
    log "Copying commands from ~/.claude/commands/"
    cp -r "$HOME/.claude/commands" "$claude_config/"
  fi

  # Create a minimal settings.json for the sandbox
  # (don't copy host settings - they may have paths that don't work in container)
  cat > "$claude_config/settings.json" << 'EOF'
{
  "permissions": {
    "allow": [],
    "deny": []
  }
}
EOF

  # Parse ruby-versions.yaml and build each version
  # Using grep/awk to avoid dependency on yq or python
  local versions_file="$SANDBOX_DIR/ruby-versions.yaml"
  if [ ! -f "$versions_file" ]; then
    error "ruby-versions.yaml not found"
    exit 1
  fi

  # Extract versions from YAML (lines like: "3.2": "3.2.6")
  local version_count=0
  local latest_version=""
  local latest_tag=""

  while IFS= read -r line; do
    # Match lines like: "3.2": "3.2.6"
    if [[ "$line" =~ \"([0-9]+\.[0-9]+)\":[[:space:]]*\"([0-9]+\.[0-9]+\.[0-9]+)\" ]]; then
      local major_minor="${BASH_REMATCH[1]}"
      local full_version="${BASH_REMATCH[2]}"
      local image_tag="ruby-${major_minor}"

      log "Building Ruby ${full_version}..."
      local build_opts="--build-arg RUBY_VERSION=${full_version}"
      if [ "$force_rebuild" = true ]; then
        build_opts="$build_opts --no-cache"
      fi
      docker build $build_opts -t "claude-sandbox:${image_tag}" .

      success "Tagged as claude-sandbox:${image_tag}"
      version_count=$((version_count + 1))

      # Track latest version for tagging
      latest_version="$full_version"
      latest_tag="$image_tag"
    fi
  done < <(grep -E '^\s*"[0-9]+\.[0-9]+":\s*"[0-9]+\.[0-9]+\.[0-9]+"' "$versions_file")

  # Tag the latest version as :latest for backward compatibility
  if [ -n "$latest_tag" ]; then
    log "Tagging claude-sandbox:${latest_tag} as claude-sandbox:latest"
    docker tag "claude-sandbox:${latest_tag}" "claude-sandbox:latest"
    version_count=$((version_count + 1))
  fi

  # Clean up copied config but keep .gitkeep so docker compose doesn't fail
  find "$claude_config" -type f ! -name '.gitkeep' -delete
  find "$claude_config" -mindepth 1 -type d -delete 2>/dev/null || true

  log "Build complete - ${version_count} images created"
}

cmd_push() {
  local registry="${CLAUDE_REGISTRY:-}"
  if [ -z "$registry" ]; then
    error "CLAUDE_REGISTRY environment variable required"
    error "Example: export CLAUDE_REGISTRY=ghcr.io/username"
    exit 1
  fi

  log "Pushing all Ruby version images to registry..."

  local versions_file="$SANDBOX_DIR/ruby-versions.yaml"
  local push_count=0

  # Push each Ruby version
  while IFS= read -r line; do
    if [[ "$line" =~ \"([0-9]+\.[0-9]+)\":[[:space:]]*\"([0-9]+\.[0-9]+\.[0-9]+)\" ]]; then
      local major_minor="${BASH_REMATCH[1]}"
      local image_tag="ruby-${major_minor}"
      local full_image="$registry/claude-sandbox:${image_tag}"

      log "Pushing $full_image..."
      docker tag "claude-sandbox:${image_tag}" "$full_image"
      docker push "$full_image"
      success "Pushed $full_image"
      push_count=$((push_count + 1))
    fi
  done < <(grep -E '^\s*"[0-9]+\.[0-9]+":\s*"[0-9]+\.[0-9]+\.[0-9]+"' "$versions_file")

  # Push latest tag
  local latest_image="$registry/claude-sandbox:latest"
  log "Pushing $latest_image..."
  docker tag "claude-sandbox:latest" "$latest_image"
  docker push "$latest_image"
  push_count=$((push_count + 1))

  log "Push complete - ${push_count} images pushed"
  log "For remote runs, use: export CLAUDE_IMAGE=$registry/claude-sandbox"
}

cmd_logs() {
  # Find most recent job
  local job=$(kubectl get jobs -l app=claude-sandbox \
    --sort-by=.metadata.creationTimestamp \
    -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null)

  if [ -z "$job" ]; then
    error "No claude-sandbox jobs found"
    exit 1
  fi

  log "Following logs for job: $job"
  kubectl logs -f "job/$job" -c claude
}

cmd_clean() {
  log "Cleaning up completed jobs..."
  kubectl delete jobs -l app=claude-sandbox,managed-by=claude-sandbox-cli \
    --field-selector status.successful=1 2>/dev/null || true
  kubectl delete jobs -l app=claude-sandbox,managed-by=claude-sandbox-cli \
    --field-selector status.failed=1 2>/dev/null || true
  log "Cleanup complete"
}

# Main
case "${1:-}" in
  local)
    shift
    cmd_local "$@"
    ;;
  remote)
    shift
    cmd_remote "$@"
    ;;
  build)
    shift
    cmd_build "$@"
    ;;
  push)
    cmd_push
    ;;
  logs)
    cmd_logs
    ;;
  clean)
    cmd_clean
    ;;
  -h|--help|help|"")
    usage
    ;;
  *)
    error "Unknown command: $1"
    usage
    exit 1
    ;;
esac
